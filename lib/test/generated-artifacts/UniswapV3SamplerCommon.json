{
    "schemaVersion": "2.0.0",
    "contractName": "UniswapV3SamplerCommon",
    "compilerOutput": {
        "abi": [],
        "devdoc": {
            "kind": "dev",
            "methods": {},
            "stateVariables": {
                "QUOTE_GAS": {
                    "details": "Gas limit for UniswapV3 calls. This is 100% a guess."
                }
            },
            "version": 1
        },
        "evm": {
            "bytecode": {
                "linkReferences": {},
                "object": "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220516c10bd559e4ee0bed0d783b0c25ff8e9413a1b331169ea1759ff75c25a356964736f6c634300060c0033",
                "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x3F DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 MLOAD PUSH13 0x10BD559E4EE0BED0D783B0C25F 0xF8 0xE9 COINBASE GASPRICE SHL CALLER GT PUSH10 0xEA1759FF75C25A356964 PUSH20 0x6F6C634300060C00330000000000000000000000 ",
                "sourceMap": "770:5292:51:-:0;;;;;;;;;;;;;;;;;;;"
            },
            "deployedBytecode": {
                "immutableReferences": {},
                "linkReferences": {},
                "object": "0x6080604052600080fdfea2646970667358221220516c10bd559e4ee0bed0d783b0c25ff8e9413a1b331169ea1759ff75c25a356964736f6c634300060c0033",
                "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 MLOAD PUSH13 0x10BD559E4EE0BED0D783B0C25F 0xF8 0xE9 COINBASE GASPRICE SHL CALLER GT PUSH10 0xEA1759FF75C25A356964 PUSH20 0x6F6C634300060C00330000000000000000000000 ",
                "sourceMap": "770:5292:51:-:0;;;;;"
            }
        }
    },
    "sourceTreeHashHex": "0x25b042729c68d4f49d737cc3ad9272edb88fa12c55124a797f7659cf76b3c190",
    "sources": {
        "./UniswapV3SamplerCommon.sol": {
            "id": 51,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"./UniswapV3.sol\";\n\ncontract UniswapV3SamplerCommon {\n    /// @dev Gas limit for UniswapV3 calls. This is 100% a guess.\n    uint256 constant internal QUOTE_GAS = 300e3;\n\n    function _getValidPoolPaths(\n        IUniswapV3Factory factory,\n        IERC20TokenV06[] memory tokenPath,\n        uint256 startIndex\n    )\n        internal\n        view\n        returns (IUniswapV3Pool[][] memory poolPaths)\n    {\n        require(\n            tokenPath.length - startIndex >= 2,\n            \"UniswapV3Sampler/tokenPath too short\"\n        );\n        uint24[3] memory validPoolFees = [\n            // The launch pool fees. Could get hairier if they add more.\n            uint24(0.0005e6),\n            uint24(0.003e6),\n            uint24(0.01e6)\n        ];\n        IUniswapV3Pool[] memory validPools =\n            new IUniswapV3Pool[](validPoolFees.length);\n        uint256 numValidPools = 0;\n        {\n            IERC20TokenV06 inputToken = tokenPath[startIndex];\n            IERC20TokenV06 outputToken = tokenPath[startIndex + 1];\n            for (uint256 i = 0; i < validPoolFees.length; ++i) {\n                IUniswapV3Pool pool =\n                factory.getPool(inputToken, outputToken, validPoolFees[i]);\n                if (_isValidPool(pool)) {\n                    validPools[numValidPools++] = pool;\n                }\n            }\n        }\n        if (numValidPools == 0) {\n            // No valid pools for this hop.\n            return poolPaths;\n        }\n        if (startIndex + 2 == tokenPath.length) {\n            // End of path.\n            poolPaths = new IUniswapV3Pool[][](numValidPools);\n            for (uint256 i = 0; i < numValidPools; ++i) {\n                poolPaths[i] = new IUniswapV3Pool[](1);\n                poolPaths[i][0] = validPools[i];\n            }\n            return poolPaths;\n        }\n        // Get paths for subsequent hops.\n        IUniswapV3Pool[][] memory subsequentPoolPaths =\n            _getValidPoolPaths(factory, tokenPath, startIndex + 1);\n        if (subsequentPoolPaths.length == 0) {\n            // Could not complete the path.\n            return poolPaths;\n        }\n        // Combine our pools with the next hop paths.\n        poolPaths = new IUniswapV3Pool[][](\n            numValidPools * subsequentPoolPaths.length\n        );\n        for (uint256 i = 0; i < numValidPools; ++i) {\n            for (uint256 j = 0; j < subsequentPoolPaths.length; ++j) {\n                uint256 o = i * subsequentPoolPaths.length + j;\n                // Prepend pool to the subsequent path.\n                poolPaths[o] =\n                    new IUniswapV3Pool[](1 + subsequentPoolPaths[j].length);\n                poolPaths[o][0] = validPools[i];\n                for (uint256 k = 0; k < subsequentPoolPaths[j].length; ++k) {\n                    poolPaths[o][1 + k] = subsequentPoolPaths[j][k];\n                }\n            }\n        }\n        return poolPaths;\n    }\n\n    function _reverseTokenPath(IERC20TokenV06[] memory tokenPath)\n        internal\n        pure\n        returns (IERC20TokenV06[] memory reversed)\n    {\n        reversed = new IERC20TokenV06[](tokenPath.length);\n        for (uint256 i = 0; i < tokenPath.length; ++i) {\n            reversed[i] = tokenPath[tokenPath.length - i - 1];\n        }\n    }\n\n    function _reversePoolPath(IUniswapV3Pool[] memory poolPath)\n        internal\n        pure\n        returns (IUniswapV3Pool[] memory reversed)\n    {\n        reversed = new IUniswapV3Pool[](poolPath.length);\n        for (uint256 i = 0; i < poolPath.length; ++i) {\n            reversed[i] = poolPath[poolPath.length - i - 1];\n        }\n    }\n\n    function _toUniswapPath(\n        IERC20TokenV06[] memory tokenPath,\n        IUniswapV3Pool[] memory poolPath\n    )\n        internal\n        view\n        returns (bytes memory uniswapPath)\n    {\n        require(\n            tokenPath.length >= 2 && tokenPath.length == poolPath.length + 1,\n            \"UniswapV3Sampler/invalid path lengths\"\n        );\n        // Uniswap paths are tightly packed as:\n        // [token0, token0token1PairFee, token1, token1Token2PairFee, token2, ...]\n        uniswapPath = new bytes(tokenPath.length * 20 + poolPath.length * 3);\n        uint256 o;\n        assembly { o := add(uniswapPath, 32) }\n        for (uint256 i = 0; i < tokenPath.length; ++i) {\n            if (i > 0) {\n                uint24 poolFee = poolPath[i - 1].fee();\n                assembly {\n                    mstore(o, shl(232, poolFee))\n                    o := add(o, 3)\n                }\n            }\n            IERC20TokenV06 token = tokenPath[i];\n            assembly {\n                mstore(o, shl(96, token))\n                o := add(o, 20)\n            }\n        }\n    }\n\n    function _isValidPool(IUniswapV3Pool pool)\n        private\n        view\n        returns (bool isValid)\n    {\n        // Check if it has been deployed.\n        {\n            uint256 codeSize;\n            assembly {\n                codeSize := extcodesize(pool)\n            }\n            if (codeSize == 0) {\n                return false;\n            }\n        }\n        // Must have a balance of both tokens.\n        if (pool.token0().balanceOf(address(pool)) == 0) {\n            return false;\n        }\n        if (pool.token1().balanceOf(address(pool)) == 0) {\n            return false;\n        }\n        return true;\n    }\n}\n"
        },
        "@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol": {
            "id": 0,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\ninterface IERC20TokenV06 {\n\n    // solhint-disable no-simple-event-func-name\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @dev send `value` token to `to` from `msg.sender`\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transfer(address to, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    /// @dev `msg.sender` approves `spender` to spend `value` tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @param value The amount of wei to be approved for transfer\n    /// @return Always true if the call has enough gas to complete execution\n    function approve(address spender, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev Query total supply of token\n    /// @return Total supply of token\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the balance of `owner`.\n    /// @param owner The address from which the balance will be retrieved\n    /// @return Balance of owner\n    function balanceOf(address owner)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the allowance for `spender` to spend from `owner`.\n    /// @param owner The address of the account owning tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the number of decimals this token has.\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n"
        },
        "./UniswapV3.sol": {
            "id": 49,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\n\ninterface IUniswapV3Quoter {\n    function factory()\n        external\n        view\n        returns (IUniswapV3Factory factory_);\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (uint256 amountOut);\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (uint256 amountIn);\n}\n\ninterface IUniswapV3Factory {\n    function getPool(IERC20TokenV06 a, IERC20TokenV06 b, uint24 fee)\n        external\n        view\n        returns (IUniswapV3Pool pool);\n}\n\ninterface IUniswapV3Pool {\n    function token0() external view returns (IERC20TokenV06);\n    function token1() external view returns (IERC20TokenV06);\n    function fee() external view returns (uint24);\n}\n\n// HACK: Keep the compiler from complaining about filenames.\ncontract UniswapV3 {}\n"
        }
    },
    "sourceCodes": {
        "./UniswapV3SamplerCommon.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"./UniswapV3.sol\";\n\ncontract UniswapV3SamplerCommon {\n    /// @dev Gas limit for UniswapV3 calls. This is 100% a guess.\n    uint256 constant internal QUOTE_GAS = 300e3;\n\n    function _getValidPoolPaths(\n        IUniswapV3Factory factory,\n        IERC20TokenV06[] memory tokenPath,\n        uint256 startIndex\n    )\n        internal\n        view\n        returns (IUniswapV3Pool[][] memory poolPaths)\n    {\n        require(\n            tokenPath.length - startIndex >= 2,\n            \"UniswapV3Sampler/tokenPath too short\"\n        );\n        uint24[3] memory validPoolFees = [\n            // The launch pool fees. Could get hairier if they add more.\n            uint24(0.0005e6),\n            uint24(0.003e6),\n            uint24(0.01e6)\n        ];\n        IUniswapV3Pool[] memory validPools =\n            new IUniswapV3Pool[](validPoolFees.length);\n        uint256 numValidPools = 0;\n        {\n            IERC20TokenV06 inputToken = tokenPath[startIndex];\n            IERC20TokenV06 outputToken = tokenPath[startIndex + 1];\n            for (uint256 i = 0; i < validPoolFees.length; ++i) {\n                IUniswapV3Pool pool =\n                factory.getPool(inputToken, outputToken, validPoolFees[i]);\n                if (_isValidPool(pool)) {\n                    validPools[numValidPools++] = pool;\n                }\n            }\n        }\n        if (numValidPools == 0) {\n            // No valid pools for this hop.\n            return poolPaths;\n        }\n        if (startIndex + 2 == tokenPath.length) {\n            // End of path.\n            poolPaths = new IUniswapV3Pool[][](numValidPools);\n            for (uint256 i = 0; i < numValidPools; ++i) {\n                poolPaths[i] = new IUniswapV3Pool[](1);\n                poolPaths[i][0] = validPools[i];\n            }\n            return poolPaths;\n        }\n        // Get paths for subsequent hops.\n        IUniswapV3Pool[][] memory subsequentPoolPaths =\n            _getValidPoolPaths(factory, tokenPath, startIndex + 1);\n        if (subsequentPoolPaths.length == 0) {\n            // Could not complete the path.\n            return poolPaths;\n        }\n        // Combine our pools with the next hop paths.\n        poolPaths = new IUniswapV3Pool[][](\n            numValidPools * subsequentPoolPaths.length\n        );\n        for (uint256 i = 0; i < numValidPools; ++i) {\n            for (uint256 j = 0; j < subsequentPoolPaths.length; ++j) {\n                uint256 o = i * subsequentPoolPaths.length + j;\n                // Prepend pool to the subsequent path.\n                poolPaths[o] =\n                    new IUniswapV3Pool[](1 + subsequentPoolPaths[j].length);\n                poolPaths[o][0] = validPools[i];\n                for (uint256 k = 0; k < subsequentPoolPaths[j].length; ++k) {\n                    poolPaths[o][1 + k] = subsequentPoolPaths[j][k];\n                }\n            }\n        }\n        return poolPaths;\n    }\n\n    function _reverseTokenPath(IERC20TokenV06[] memory tokenPath)\n        internal\n        pure\n        returns (IERC20TokenV06[] memory reversed)\n    {\n        reversed = new IERC20TokenV06[](tokenPath.length);\n        for (uint256 i = 0; i < tokenPath.length; ++i) {\n            reversed[i] = tokenPath[tokenPath.length - i - 1];\n        }\n    }\n\n    function _reversePoolPath(IUniswapV3Pool[] memory poolPath)\n        internal\n        pure\n        returns (IUniswapV3Pool[] memory reversed)\n    {\n        reversed = new IUniswapV3Pool[](poolPath.length);\n        for (uint256 i = 0; i < poolPath.length; ++i) {\n            reversed[i] = poolPath[poolPath.length - i - 1];\n        }\n    }\n\n    function _toUniswapPath(\n        IERC20TokenV06[] memory tokenPath,\n        IUniswapV3Pool[] memory poolPath\n    )\n        internal\n        view\n        returns (bytes memory uniswapPath)\n    {\n        require(\n            tokenPath.length >= 2 && tokenPath.length == poolPath.length + 1,\n            \"UniswapV3Sampler/invalid path lengths\"\n        );\n        // Uniswap paths are tightly packed as:\n        // [token0, token0token1PairFee, token1, token1Token2PairFee, token2, ...]\n        uniswapPath = new bytes(tokenPath.length * 20 + poolPath.length * 3);\n        uint256 o;\n        assembly { o := add(uniswapPath, 32) }\n        for (uint256 i = 0; i < tokenPath.length; ++i) {\n            if (i > 0) {\n                uint24 poolFee = poolPath[i - 1].fee();\n                assembly {\n                    mstore(o, shl(232, poolFee))\n                    o := add(o, 3)\n                }\n            }\n            IERC20TokenV06 token = tokenPath[i];\n            assembly {\n                mstore(o, shl(96, token))\n                o := add(o, 20)\n            }\n        }\n    }\n\n    function _isValidPool(IUniswapV3Pool pool)\n        private\n        view\n        returns (bool isValid)\n    {\n        // Check if it has been deployed.\n        {\n            uint256 codeSize;\n            assembly {\n                codeSize := extcodesize(pool)\n            }\n            if (codeSize == 0) {\n                return false;\n            }\n        }\n        // Must have a balance of both tokens.\n        if (pool.token0().balanceOf(address(pool)) == 0) {\n            return false;\n        }\n        if (pool.token1().balanceOf(address(pool)) == 0) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\ninterface IERC20TokenV06 {\n\n    // solhint-disable no-simple-event-func-name\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @dev send `value` token to `to` from `msg.sender`\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transfer(address to, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    /// @dev `msg.sender` approves `spender` to spend `value` tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @param value The amount of wei to be approved for transfer\n    /// @return Always true if the call has enough gas to complete execution\n    function approve(address spender, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev Query total supply of token\n    /// @return Total supply of token\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the balance of `owner`.\n    /// @param owner The address from which the balance will be retrieved\n    /// @return Balance of owner\n    function balanceOf(address owner)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the allowance for `spender` to spend from `owner`.\n    /// @param owner The address of the account owning tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the number of decimals this token has.\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n",
        "./UniswapV3.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\n\ninterface IUniswapV3Quoter {\n    function factory()\n        external\n        view\n        returns (IUniswapV3Factory factory_);\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (uint256 amountOut);\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (uint256 amountIn);\n}\n\ninterface IUniswapV3Factory {\n    function getPool(IERC20TokenV06 a, IERC20TokenV06 b, uint24 fee)\n        external\n        view\n        returns (IUniswapV3Pool pool);\n}\n\ninterface IUniswapV3Pool {\n    function token0() external view returns (IERC20TokenV06);\n    function token1() external view returns (IERC20TokenV06);\n    function fee() external view returns (uint24);\n}\n\n// HACK: Keep the compiler from complaining about filenames.\ncontract UniswapV3 {}\n"
    },
    "compiler": {
        "name": "solc",
        "version": "0.6.12+commit.27d51765",
        "settings": {
            "remappings": [
                "@0x/contracts-utils=/home/merklejerk/code/0x-protocol/node_modules/@0x/contracts-utils",
                "@0x/contracts-erc20=/home/merklejerk/code/0x-protocol/node_modules/@0x/contracts-erc20",
                "@0x/contracts-zero-ex=/home/merklejerk/code/0x-protocol/packages/asset-swapper/node_modules/@0x/contracts-zero-ex"
            ],
            "optimizer": {
                "enabled": true,
                "runs": 200,
                "details": {
                    "yul": true,
                    "deduplicate": true
                }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "devdoc",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap"
                    ]
                }
            },
            "evmVersion": "istanbul"
        }
    },
    "chains": {}
}
